%% Do not modify this file, it is automatically
%% generated by abnfc. All changes will be lost
%% when it is regenerated.
%% Generated by abnfc_gen on 2009-02-24 17:14:16

-module(abnfc_rfc4234).

-export([]).

-compile(export_all).

-include("abnfc_rfc4234.hrl").

rulelist() ->
    fun (T) ->
	    __P = '__repeat'(1, infinity,
			     '__alt'([rule(),
				      '__seq'(['__repeat'(0, infinity,
							  'c-wsp'()),
					       'c-nl'()])])),
	    case __P(T) of
	      {ok, _YY, __Rest} ->
		  __Ret = begin
			    #rulelist{rules =
					  [Rule || Rule <- _YY, is_tuple(Rule)]}
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

rulelist_dec(Str) -> (rulelist())(Str).

rule() ->
    fun (T) ->
	    __P = '__seq'([rulename(), 'defined-as'(), elements(),
			   fun (Str) ->
				   case ('__seq'(['__repeat'(0, infinity,
							     'WSP'()),
						  fun ([C | Tl]) when C == 58 ->
							  {ok, C, Tl};
						      (_) -> fail
						  end,
						  '__repeat'(0, infinity,
							     'WSP'()),
						  erlangcode()]))(Str)
				       of
				     fail -> {ok, [], Str};
				     {ok, _Res, _Tail} -> {ok, [_Res], _Tail}
				   end
			   end,
			   'c-nl'()]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3, _YY4, _YY5] = _YY, __Rest} ->
		  __Ret = begin
			    #rule{type = _YY2, name = element(2, _YY1),
				  body = _YY3,
				  code =
				      case _YY4 of
					[[_, _, _, Code]] -> Code;
					[] -> nocode
				      end}
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

rule_dec(Str) -> (rule())(Str).

rulename() ->
    fun (T) ->
	    __P = '__seq'(['ALPHA'(),
			   '__repeat'(0, infinity,
				      '__alt'([fun ([C1 | Tl]) when C1 == 45 ->
						       {ok, C1, Tl};
						   (_) -> fail
					       end,
					       'ALPHA'(), 'DIGIT'()]))]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin
			    #rulename{name = list_to_atom(lists:flatten(_YY))}
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

rulename_dec(Str) -> (rulename())(Str).

'defined-as'() ->
    fun (T) ->
	    __P = '__seq'(['__repeat'(0, infinity, 'c-wsp'()),
			   '__alt'([fun ([C1 | Tl]) when C1 == 61 ->
					    {ok, C1, Tl};
					(_) -> fail
				    end,
				    fun ([C1, C2 | Tl])
					    when C1 == 61, C2 == 47 ->
					    {ok, [C1, C2], Tl};
					(_) -> fail
				    end]),
			   '__repeat'(0, infinity, 'c-wsp'())]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin
			    case _YY2 of
			      61 -> def_rule;
			      _ -> app_rule
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'defined-as_dec'(Str) -> ('defined-as'())(Str).

elements() ->
    fun (T) ->
	    __P = '__seq'([alternation(),
			   '__repeat'(0, infinity, 'c-wsp'())]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin _YY1 end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

elements_dec(Str) -> (elements())(Str).

'c-wsp'() ->
    fun (T) ->
	    __P = '__alt'(['WSP'(), '__seq'(['c-nl'(), 'WSP'()])]),
	    case __P(T) of
	      {ok, _YY, __Rest} ->
		  __Ret = begin 'c-wsp' end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'c-wsp_dec'(Str) -> ('c-wsp'())(Str).

'c-nl'() ->
    fun (T) ->
	    __P = '__alt'([comment(), 'CRLF'()]),
	    case __P(T) of
	      {ok, _YY, __Rest} ->
		  __Ret = begin 'c-nl' end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'c-nl_dec'(Str) -> ('c-nl'())(Str).

comment() ->
    fun (T) ->
	    __P = '__seq'([fun ([C | Tl]) when C == 59 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(0, infinity,
				      '__alt'(['WSP'(), 'VCHAR'()])),
			   'CRLF'()]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin comment end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

comment_dec(Str) -> (comment())(Str).

alternation() ->
    fun (T) ->
	    __P = '__seq'([concatenation(),
			   '__repeat'(0, infinity,
				      '__seq'(['__repeat'(0, infinity,
							  'c-wsp'()),
					       fun ([C | Tl]) when C == 47 ->
						       {ok, C, Tl};
						   (_) -> fail
					       end,
					       '__repeat'(0, infinity,
							  'c-wsp'()),
					       concatenation()]))]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin
			    case [Alt || [_, _, _, Alt] <- _YY2] of
			      [] -> _YY1;
			      Alts -> #alt{alts = [_YY1 | Alts]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

alternation_dec(Str) -> (alternation())(Str).

concatenation() ->
    fun (T) ->
	    __P = '__seq'([repetition(),
			   '__repeat'(0, infinity,
				      '__seq'(['__repeat'(1, infinity,
							  'c-wsp'()),
					       repetition()]))]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin
			    case [Rule || [_, Rule] <- _YY2] of
			      [] -> _YY1;
			      More -> #seq{elements = [_YY1 | More]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

concatenation_dec(Str) -> (concatenation())(Str).

repetition() ->
    fun (T) ->
	    __P = '__seq'([fun (Str) ->
				   case (repeat())(Str) of
				     fail -> {ok, [], Str};
				     {ok, _Res, _Tail} -> {ok, [_Res], _Tail}
				   end
			   end,
			   element()]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin
			    case _YY1 of
			      [{Min, Max}] ->
				  #repeat{min = Min, max = Max, body = _YY2};
			      [] -> _YY2
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

repetition_dec(Str) -> (repetition())(Str).

repeat() ->
    fun (T) ->
	    __P = '__alt'(['__seq'(['__repeat'(0, infinity,
					       'DIGIT'()),
				    fun ([C | Tl]) when C == 42 -> {ok, C, Tl};
					(_) -> fail
				    end,
				    '__repeat'(0, infinity, 'DIGIT'())]),
			   '__repeat'(1, infinity, 'DIGIT'())]),
	    case __P(T) of
	      {ok, _YY, __Rest} ->
		  __Ret = begin
			    case _YY of
			      [[], 42, []] -> {0, infinity};
			      [Min, 42, []] -> {list_to_integer(Min), infinity};
			      [[], 42, Max] -> {0, list_to_integer(Max)};
			      [Min, 42, Max] ->
				  {list_to_integer(Min), list_to_integer(Max)};
			      Number ->
				  {list_to_integer(Number),
				   list_to_integer(Number)}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

repeat_dec(Str) -> (repeat())(Str).

element() ->
    fun (T) ->
	    __P = '__alt'([rulename(), group(), option(),
			   'char-val'(), 'num-val'(), 'prose-val'()]),
	    __P(T)
    end.

element_dec(Str) -> (element())(Str).

group() ->
    fun (T) ->
	    __P = '__seq'([fun ([C | Tl]) when C == 40 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(0, infinity, 'c-wsp'()), alternation(),
			   '__repeat'(0, infinity, 'c-wsp'()),
			   fun ([C | Tl]) when C == 41 -> {ok, C, Tl};
			       (_) -> fail
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3, _YY4, _YY5] = _YY, __Rest} ->
		  __Ret = begin _YY3 end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

group_dec(Str) -> (group())(Str).

option() ->
    fun (T) ->
	    __P = '__seq'([fun ([C | Tl]) when C == 91 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(0, infinity, 'c-wsp'()), alternation(),
			   '__repeat'(0, infinity, 'c-wsp'()),
			   fun ([C | Tl]) when C == 93 -> {ok, C, Tl};
			       (_) -> fail
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3, _YY4, _YY5] = _YY, __Rest} ->
		  __Ret = begin {repeat, 0, 1, _YY3} end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

option_dec(Str) -> (option())(Str).

'char-val'() ->
    fun (T) ->
	    __P = '__seq'(['DQUOTE'(),
			   '__repeat'(0, infinity,
				      fun ([C1 | Tl])
					      when (C1 >= 32) and (C1 =< 33) or
						     (C1 >= 35) and
						       (C1 =< 126) ->
					      {ok, C1, Tl};
					  (_) -> fail
				      end),
			   'DQUOTE'()]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin
			    F = fun (Char) ->
					case {string:to_lower(Char),
					      string:to_upper(Char)}
					    of
					  {Char, Char} ->
					      #char_val{value = Char};
					  {Low, Up} ->
					      #char_alt{alts =
							    [#char_val{value =
									   Low},
							     #char_val{value =
									   Up}]}
					end
				end,
			    case _YY2 of
			      [C] -> F(C);
			      Chars ->
				  #char_seq{elements = [F(C) || C <- Chars]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'char-val_dec'(Str) -> ('char-val'())(Str).

'num-val'() ->
    fun (T) ->
	    __P = '__seq'([fun ([C | Tl]) when C == 37 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__alt'(['bin-val'(), 'dec-val'(), 'hex-val'()])]),
	    case __P(T) of
	      {ok, [_YY1, _YY2] = _YY, __Rest} ->
		  __Ret = begin _YY2 end, {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'num-val_dec'(Str) -> ('num-val'())(Str).

'bin-val'() ->
    fun (T) ->
	    __P = '__seq'([fun ([C1 | Tl])
				   when (C1 == 98) or (C1 == 66) ->
				   {ok, C1, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(1, infinity, 'BIT'()),
			   fun (Str) ->
				   case ('__alt'(['__repeat'(1, infinity,
							     '__seq'([fun ([C
									    | Tl])
									      when
										C
										  ==
										  46 ->
									      {ok,
									       C,
									       Tl};
									  (_) ->
									      fail
								      end,
								      '__repeat'(1,
										 infinity,
										 'BIT'())])),
						  '__seq'([fun ([C | Tl])
								   when C ==
									  45 ->
								   {ok, C, Tl};
							       (_) -> fail
							   end,
							   '__repeat'(1,
								      infinity,
								      'BIT'())])]))(Str)
				       of
				     fail -> {ok, [], Str};
				     {ok, _Res, _Tail} -> {ok, [_Res], _Tail}
				   end
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin
			    First = bin_to_int(_YY2),
			    case _YY3 of
			      [] -> #char_val{value = First};
			      [[45, To]] ->
				  #char_range{from = First,
					      to = bin_to_int(To)};
			      [Vals] ->
				  #char_seq{elements =
						[#char_val{value = First}
						 | [#char_val{value =
								  bin_to_int(Val)}
						    || [46, Val] <- Vals]]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'bin-val_dec'(Str) -> ('bin-val'())(Str).

'dec-val'() ->
    fun (T) ->
	    __P = '__seq'([fun ([C1 | Tl])
				   when (C1 == 100) or (C1 == 68) ->
				   {ok, C1, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(1, infinity, 'DIGIT'()),
			   fun (Str) ->
				   case ('__alt'(['__repeat'(1, infinity,
							     '__seq'([fun ([C
									    | Tl])
									      when
										C
										  ==
										  46 ->
									      {ok,
									       C,
									       Tl};
									  (_) ->
									      fail
								      end,
								      '__repeat'(1,
										 infinity,
										 'DIGIT'())])),
						  '__seq'([fun ([C | Tl])
								   when C ==
									  45 ->
								   {ok, C, Tl};
							       (_) -> fail
							   end,
							   '__repeat'(1,
								      infinity,
								      'DIGIT'())])]))(Str)
				       of
				     fail -> {ok, [], Str};
				     {ok, _Res, _Tail} -> {ok, [_Res], _Tail}
				   end
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin
			    First = list_to_integer(_YY2),
			    case _YY3 of
			      [] -> #char_val{value = First};
			      [[45, To]] ->
				  #char_range{from = First,
					      to = list_to_integer(To)};
			      [Vals] ->
				  #char_seq{elements =
						[#char_val{value = First}
						 | [#char_val{value =
								  list_to_integer(Val)}
						    || [46, Val] <- Vals]]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'dec-val_dec'(Str) -> ('dec-val'())(Str).

'hex-val'() ->
    fun (T) ->
	    __P = '__seq'([fun ([C1 | Tl])
				   when (C1 == 120) or (C1 == 88) ->
				   {ok, C1, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(1, infinity, 'HEXDIG'()),
			   fun (Str) ->
				   case ('__alt'(['__repeat'(1, infinity,
							     '__seq'([fun ([C
									    | Tl])
									      when
										C
										  ==
										  46 ->
									      {ok,
									       C,
									       Tl};
									  (_) ->
									      fail
								      end,
								      '__repeat'(1,
										 infinity,
										 'HEXDIG'())])),
						  '__seq'([fun ([C | Tl])
								   when C ==
									  45 ->
								   {ok, C, Tl};
							       (_) -> fail
							   end,
							   '__repeat'(1,
								      infinity,
								      'HEXDIG'())])]))(Str)
				       of
				     fail -> {ok, [], Str};
				     {ok, _Res, _Tail} -> {ok, [_Res], _Tail}
				   end
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin
			    First = hex_to_int(_YY2),
			    case _YY3 of
			      [] -> #char_val{value = First};
			      [[45, To]] ->
				  #char_range{from = First,
					      to = hex_to_int(To)};
			      [Vals] ->
				  #char_seq{elements =
						[#char_val{value = First}
						 | [#char_val{value =
								  hex_to_int(Val)}
						    || [46, Val] <- Vals]]}
			    end
			  end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'hex-val_dec'(Str) -> ('hex-val'())(Str).

'prose-val'() ->
    fun (T) ->
	    __P = '__seq'([fun ([C | Tl]) when C == 60 ->
				   {ok, C, Tl};
			       (_) -> fail
			   end,
			   '__repeat'(0, infinity,
				      fun ([C1 | Tl])
					      when (C1 >= 32) and (C1 =< 61) or
						     (C1 >= 63) and
						       (C1 =< 126) ->
					      {ok, C1, Tl};
					  (_) -> fail
				      end),
			   fun ([C | Tl]) when C == 62 -> {ok, C, Tl};
			       (_) -> fail
			   end]),
	    case __P(T) of
	      {ok, [_YY1, _YY2, _YY3] = _YY, __Rest} ->
		  __Ret = begin {'prose-val', lists:flatten(_YY2)} end,
		  {ok, __Ret, __Rest};
	      fail -> fail
	    end
    end.

'prose-val_dec'(Str) -> ('prose-val'())(Str).

'__alt'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, R, T1} -> {ok, R, T1};
	      fail ->
		  case Ps of
		    [] -> fail;
		    _ -> ('__alt'(Ps))(T)
		  end
	    end
    end.

'__repeat'(Min, Max, P) -> '__repeat'(Min, Max, P, 0).

'__repeat'(Min, Max, P, Found) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} when Max == Found + 1 -> {ok, [R1], T1};
	      {ok, R1, T1} ->
		  case ('__repeat'(Min, Max, P, Found + 1))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail when Found >= Min -> {ok, [R1], T1};
		    fail -> fail
		  end;
	      fail when Found >= Min -> {ok, [], T};
	      fail -> fail
	    end
    end.

'__seq'([P | Ps]) ->
    fun (T) ->
	    case P(T) of
	      {ok, R1, T1} ->
		  case ('__seq'(Ps))(T1) of
		    {ok, R2, T2} -> {ok, [R1 | R2], T2};
		    fail -> fail
		  end;
	      fail -> fail
	    end
    end;
'__seq'([]) -> fun (T) -> {ok, [], T} end.
